diff --git a/module/IMG_savepng.c b/module/IMG_savepng.c
index 54a4032..90465b8 100644
--- a/module/IMG_savepng.c
+++ b/module/IMG_savepng.c
@@ -26,9 +26,11 @@
  */
 #include <stdlib.h>
 #include <SDL/SDL.h>
-#include <SDL/SDL_byteorder.h>
+#include <SDL/SDL_compat.h>
+#include <SDL/SDL_endian.h>
 #include <png.h>
 #include <zlib.h>
+#include "sdl_blitmap.h"
 #include "IMG_savepng.h"
 
 #ifndef png_voidp
@@ -127,17 +129,17 @@ int IMG_SavePNG_RW(SDL_RWops *src, SDL_Surface *surf,int compression){
 		}
 		png_set_PLTE(png_ptr,info_ptr,palette,fmt->palette->ncolors);
 		if (surf->flags&SDL_SRCCOLORKEY) {
-			palette_alpha=(Uint8 *)malloc((fmt->colorkey+1)*sizeof(Uint8));
+			palette_alpha=(Uint8 *)malloc((surf->map->info.colorkey+1)*sizeof(Uint8));
 			if (!palette_alpha) {
 				SDL_SetError("Couldn't create memory for palette transparency");
 				goto savedone;
 			}
 			/* FIXME: memset? */
-			for (i=0;i<(fmt->colorkey+1);i++) {
+			for (i=0;i<(surf->map->info.colorkey+1);i++) {
 				palette_alpha[i]=255;
 			}
-			palette_alpha[fmt->colorkey]=0;
-			png_set_tRNS(png_ptr,info_ptr,palette_alpha,fmt->colorkey+1,NULL);
+			palette_alpha[surf->map->info.colorkey]=0;
+			png_set_tRNS(png_ptr,info_ptr,palette_alpha,surf->map->info.colorkey+1,NULL);
 		}
 	}else{ /* Truecolor */
 		if (fmt->Amask) {
@@ -229,7 +231,7 @@ int IMG_SavePNG_RW(SDL_RWops *src, SDL_Surface *surf,int compression){
 				goto savedone;
 			}
 			if(surf->flags&SDL_SRCALPHA){
-				temp_alpha=fmt->alpha;
+				temp_alpha=surf->map->info.a;
 				used_alpha=1;
 				SDL_SetAlpha(surf,0,255); /* Set for an opaque blit */
 			}else{
diff --git a/module/ffdecode.c b/module/ffdecode.c
index d29d829..7e89170 100644
--- a/module/ffdecode.c
+++ b/module/ffdecode.c
@@ -1081,7 +1081,7 @@ static int stream_component_open(VideoState *is, int stream_index)
         is->video_current_pts_time = av_gettime();
 
         packet_queue_init(&is->videoq);
-        is->video_tid = SDL_CreateThread(video_thread, is);
+        is->video_tid = SDL_CreateThread(video_thread, "renpyvideothread", is);
         break;
     default:
         break;
@@ -1392,7 +1392,7 @@ VideoState *ffpy_stream_open(SDL_RWops *rwops, const char *filename)
     is->quit_mutex = SDL_CreateMutex();
     is->quit_cond = SDL_CreateCond();
     
-    is->parse_tid = SDL_CreateThread(decode_thread, is);
+    is->parse_tid = SDL_CreateThread(decode_thread, "renpydecodethread", is);
 
     is->first_frame = 1;
 
diff --git a/module/glcompat.h b/module/glcompat.h
index 0921592..f9b3633 100644
--- a/module/glcompat.h
+++ b/module/glcompat.h
@@ -13,6 +13,20 @@
 #if defined ANDROID
 
 #define RENPY_GLES_1
+#include <GLES/gl.h>
+#include <GLES/glext.h>
+
+#elif __APPLE__
+
+#include "TargetConditionals.h"
+
+#if TARGET_OS_IPHONE    
+
+#define RENPY_GLES_1
+#include <ES1/gl.h>
+#include <ES1/glext.h>
+
+#endif
 
 #elif defined ANGLE
 
@@ -27,9 +41,6 @@
 
 #if defined RENPY_GLES_1
 
-#include <GLES/gl.h>
-#include <GLES/glext.h>
-
 #define glOrtho glOrthof
 
 #define GL_SOURCE0_ALPHA GL_SRC0_ALPHA
@@ -51,7 +62,6 @@
 
 #endif
 
-
 #if defined RENPY_GLES_2
 
 #include <EGL/egl.h>
diff --git a/module/pss.c b/module/pss.c
index ea7d881..7d42c3e 100644
--- a/module/pss.c
+++ b/module/pss.c
@@ -1076,7 +1076,7 @@ void PSS_init(int freq, int stereo, int samples, int status) {
     }
 
     audio_spec.freq = freq;
-    audio_spec.format = AUDIO_S16SYS;
+    audio_spec.format = AUDIO_S32SYS;
     audio_spec.channels = stereo;
     audio_spec.samples = samples;
     audio_spec.callback = callback;
diff --git a/module/rwobject.c b/module/rwobject.c
index f53d110..f9f85f8 100644
--- a/module/rwobject.c
+++ b/module/rwobject.c
@@ -45,15 +45,15 @@ typedef struct
 }RWHelper;
 
 
-static int rw_seek(SDL_RWops* context, int offset, int whence);
-static int rw_read(SDL_RWops* context, void* ptr, int size, int maxnum);
-static int rw_write(SDL_RWops* context, const void* ptr, int size, int maxnum);
+static long rw_seek(SDL_RWops* context, long offset, int whence);
+static size_t rw_read(SDL_RWops* context, void* ptr, size_t size, size_t maxnum);
+static size_t rw_write(SDL_RWops* context, const void* ptr, size_t size, size_t maxnum);
 static int rw_close(SDL_RWops* context);
 
 #ifdef WITH_THREAD
-static int rw_seek_th(SDL_RWops* context, int offset, int whence);
-static int rw_read_th(SDL_RWops* context, void* ptr, int size, int maxnum);
-static int rw_write_th(SDL_RWops* context, const void* ptr, int size, int maxnum);
+static long rw_seek_th(SDL_RWops* context, long offset, int whence);
+static size_t rw_read_th(SDL_RWops* context, void* ptr, size_t size, size_t maxnum);
+static size_t rw_write_th(SDL_RWops* context, const void* ptr, size_t size, size_t maxnum);
 static int rw_close_th(SDL_RWops* context);
 #endif
 
@@ -147,7 +147,7 @@ static int RWopsCheckPython(SDL_RWops* rw)
 }
 
 
-static int rw_seek(SDL_RWops* context, int offset, int whence)
+static long rw_seek(SDL_RWops* context, long offset, int whence)
 {
 	RWHelper* helper = (RWHelper*)context->hidden.unknown.data1;
 	PyObject* result;
@@ -158,7 +158,7 @@ static int rw_seek(SDL_RWops* context, int offset, int whence)
 
 	if(!(offset == 0 && whence == SEEK_CUR)) /*being called only for 'tell'*/
 	{
-		result = PyObject_CallFunction(helper->seek, "ii", offset, whence);
+		result = PyObject_CallFunction(helper->seek, "li", offset, whence);
 		if(!result)
 			return -1;
 		Py_DECREF(result);
@@ -175,7 +175,7 @@ static int rw_seek(SDL_RWops* context, int offset, int whence)
 }
 
 
-static int rw_read(SDL_RWops* context, void* ptr, int size, int maxnum)
+static size_t rw_read(SDL_RWops* context, void* ptr, size_t size, size_t maxnum)
 {
 	RWHelper* helper = (RWHelper*)context->hidden.unknown.data1;
 	PyObject* result;
@@ -184,7 +184,7 @@ static int rw_read(SDL_RWops* context, void* ptr, int size, int maxnum)
 	if(!helper->read)
 		return -1;
 
-	result = PyObject_CallFunction(helper->read, "i", size * maxnum);
+	result = PyObject_CallFunction(helper->read, "l", size * maxnum);
 	if(!result)
 		return -1;
 
@@ -203,7 +203,7 @@ static int rw_read(SDL_RWops* context, void* ptr, int size, int maxnum)
 }
 
 
-static int rw_write(SDL_RWops* context, const void* ptr, int size, int num)
+static size_t rw_write(SDL_RWops* context, const void* ptr, size_t size, size_t num)
 {
 	RWHelper* helper = (RWHelper*)context->hidden.unknown.data1;
 	PyObject* result;
@@ -293,7 +293,7 @@ static int RWopsCheckPythonThreaded(SDL_RWops* rw)
 }
 
 #ifdef WITH_THREAD
-static int rw_seek_th(SDL_RWops* context, int offset, int whence)
+static long rw_seek_th(SDL_RWops* context, long offset, int whence)
 {
 	RWHelper* helper = (RWHelper*)context->hidden.unknown.data1;
 	PyObject* result;
@@ -308,7 +308,7 @@ static int rw_seek_th(SDL_RWops* context, int offset, int whence)
 
 	if(!(offset == 0 && whence == SEEK_CUR)) /*being called only for 'tell'*/
 	{
-		result = PyObject_CallFunction(helper->seek, "ii", offset, whence);
+		result = PyObject_CallFunction(helper->seek, "li", offset, whence);
 		if(!result) {
                     PyErr_Clear();
                     PyThreadState_Swap(oldstate);
@@ -338,7 +338,7 @@ static int rw_seek_th(SDL_RWops* context, int offset, int whence)
 }
 
 
-static int rw_read_th(SDL_RWops* context, void* ptr, int size, int maxnum)
+static size_t rw_read_th(SDL_RWops* context, void* ptr, size_t size, size_t maxnum)
 {
 	RWHelper* helper = (RWHelper*)context->hidden.unknown.data1;
 	PyObject* result;
@@ -351,7 +351,7 @@ static int rw_read_th(SDL_RWops* context, void* ptr, int size, int maxnum)
         PyEval_AcquireLock();
         oldstate = PyThreadState_Swap(helper->thread);
 
-	result = PyObject_CallFunction(helper->read, "i", size * maxnum);
+	result = PyObject_CallFunction(helper->read, "l", size * maxnum);
 	if(!result) {
                 PyThreadState_Swap(oldstate);
                 PyEval_ReleaseLock();
@@ -380,7 +380,7 @@ static int rw_read_th(SDL_RWops* context, void* ptr, int size, int maxnum)
 }
 
 
-static int rw_write_th(SDL_RWops* context, const void* ptr, int size, int num)
+static size_t rw_write_th(SDL_RWops* context, const void* ptr, size_t size, size_t num)
 {
 	RWHelper* helper = (RWHelper*)context->hidden.unknown.data1;
 	PyObject* result;
diff --git a/module/sdl_blitmap.h b/module/sdl_blitmap.h
new file mode 100644
index 0000000..15232c6
--- /dev/null
+++ b/module/sdl_blitmap.h
@@ -0,0 +1,31 @@
+typedef struct
+{
+    Uint8 *src;
+    int src_w, src_h;
+    int src_pitch;
+    int src_skip;
+    Uint8 *dst;
+    int dst_w, dst_h;
+    int dst_pitch;
+    int dst_skip;
+    SDL_PixelFormat *src_fmt;
+    SDL_PixelFormat *dst_fmt;
+    Uint8 *table;
+    int flags;
+    Uint32 colorkey;
+    Uint8 r, g, b, a;
+} SDL_BlitInfo;
+
+typedef struct SDL_BlitMap
+{
+    SDL_Surface *dst;
+    int identity;
+    SDL_blit blit;
+    void *data;
+    SDL_BlitInfo info;
+
+    /* the version count matches the destination; mismatch indicates
+       an invalid mapping */
+    Uint32 dst_palette_version;
+    Uint32 src_palette_version;
+} SDL_BlitMap;
diff --git a/module/setup.py b/module/setup.py
index 828f3fd..e181449 100644
--- a/module/setup.py
+++ b/module/setup.py
@@ -8,7 +8,7 @@ import os
 os.chdir(os.path.abspath(os.path.dirname(sys.argv[0])))
 
 import setuplib
-from setuplib import android, include, library, cython, cmodule, pymodule, copyfile, find_unnecessary_gen
+from setuplib import android, ios, include, library, cython, cmodule, pymodule, copyfile, find_unnecessary_gen
 
 # These control the level of optimization versus debugging.
 setuplib.extra_compile_args = [ "-Wno-unused-function" ]
@@ -72,7 +72,7 @@ if has_fribidi and not android:
 # Sound.
 pymodule("pysdlsound.__init__")
 
-if not android:
+if not (android):
 
     sound = [ "avformat", "avcodec", "avutil", "z" ]
     if has_swscale:
@@ -80,7 +80,8 @@ if not android:
 
     cython(
         "pysdlsound.sound",
-        [ "pss.c", "rwobject.c", "ffdecode.c" ],
+        # [ "pss.c", "rwobject.c", "ffdecode.c" ],
+        [ "pss.c", "ffdecode.c" ],
         libs = sdl + sound)
 
 
@@ -91,6 +92,8 @@ cython("renpy.display.accelerator", libs=[ 'z', 'm' ])
 # Gl.
 if android:
     glew_libs = [ 'GLESv1_CM', 'z', 'm' ]
+elif ios:
+    glew_libs = [ 'OpenGLES' ]
 elif has_libglew:
     glew_libs = [ 'GLEW' ]
 else:
@@ -98,8 +101,8 @@ else:
 
 cython("renpy.gl.gldraw", libs=glew_libs )
 cython("renpy.gl.gltexture", libs=glew_libs)
-cython("renpy.gl.glenviron_fixed", libs=glew_libs, compile_if=not android)
-cython("renpy.gl.glenviron_shader", libs=glew_libs, compile_if=not android)
+cython("renpy.gl.glenviron_fixed", libs=glew_libs, compile_if=not (android or ios))
+cython("renpy.gl.glenviron_shader", libs=glew_libs, compile_if=not (android or ios))
 cython("renpy.gl.glenviron_limited", libs=glew_libs)
 cython("renpy.gl.glrtt_copy", libs=glew_libs)
 cython("renpy.gl.glrtt_fbo", libs=glew_libs)
diff --git a/module/setuplib.py b/module/setuplib.py
index 48cd065..dc7f980 100644
--- a/module/setuplib.py
+++ b/module/setuplib.py
@@ -9,6 +9,7 @@ import distutils.core
 
 # This flag determines if we are compiling for Android or not.
 android = "RENPY_ANDROID" in os.environ
+ios = "RENIOS_IOS" in os.environ
 
 # The cython command.
 cython_command = os.environ.get("RENPY_CYTHON", None)
@@ -19,7 +20,7 @@ cython_command = os.environ.get("RENPY_CYTHON", None)
 
 # The install variable is a list of directories that have Ren'Py
 # dependencies installed in them.
-if not android:
+if not (android or ios):
     install = os.environ.get("RENPY_DEPS_INSTALL", "/usr")
     install = install.split("::")
     install = [ os.path.abspath(i) for i in install ]
@@ -45,7 +46,7 @@ def include(header, directory=None, optional=True):
         If given, returns False rather than abandoning the process.
     """
     
-    if android:
+    if (android or ios):
         return True
     
     for i in install:
@@ -84,7 +85,7 @@ def library(name, optional=False):
         rather than reporting an error.
     """
     
-    if android:
+    if (android or ios):
         return True
     
     for i in install:
diff --git a/renpy/__init__.py b/renpy/__init__.py
index 91239c9..b94adc4 100644
--- a/renpy/__init__.py
+++ b/renpy/__init__.py
@@ -265,14 +265,21 @@ windows = False
 macintosh = False
 linux = False
 android = False
+ios = False
 
-import platform
+# Ren'iOS
+# mac_ver() tries to use expat, which we don't have in our Python.
+# Remove this checking code, and hard-code platform as 'ios'.
 
-if platform.win32_ver()[0]:
-    windows = True
-elif platform.mac_ver()[0]:
-    macintosh = True
-else:
-    linux = True
+# import platform
+
+# if platform.win32_ver()[0]:
+#     windows = True
+# elif platform.mac_ver()[0]:
+#     macintosh = True
+# else:
+#     linux = True
+
+ios = True
     
 # The android init code in renpy.py will set linux=False and android=True.
diff --git a/renpy/display/core.py b/renpy/display/core.py
index 48102dc..cce6252 100644
--- a/renpy/display/core.py
+++ b/renpy/display/core.py
@@ -58,6 +58,7 @@ REDRAW = pygame.USEREVENT + 7
 # All events except for TIMEEVENT and REDRAW
 ALL_EVENTS = [ i for i in range(0, REDRAW + 1) if i != TIMEEVENT and i != REDRAW ]
 
+
 # The number of msec between periodic events.
 PERIODIC_INTERVAL = 50
 
@@ -66,10 +67,10 @@ time_base = None
 
 def init_time():
     global time_base
-    time_base = time.time() - pygame.time.get_ticks() / 1000.0
+    time_base = time.time() - pygame.pygametime.get_ticks() / 1000.0
 
 def get_time():
-    return time_base + pygame.time.get_ticks() / 1000.0
+    return time_base + pygame.pygametime.get_ticks() / 1000.0
 
 
 def displayable_by_tag(layer, tag):
@@ -1166,7 +1167,7 @@ class Interface(object):
             self.safe_mode = True
             
         # Setup periodic event.
-        pygame.time.set_timer(PERIODIC, PERIODIC_INTERVAL)
+        pygame.pygametime.set_timer(PERIODIC, PERIODIC_INTERVAL)
 
         # Don't grab the screen.
         pygame.event.set_grab(False)
@@ -1564,7 +1565,7 @@ class Interface(object):
 
         ev = pygame.event.poll()
 
-        if ev.type == pygame.NOEVENT:
+        if ev.type == pygame.FIRSTEVENT:
             # Seems to prevent the CPU from speeding up.
             renpy.display.draw.event_peek_sleep()
             return None
@@ -1727,9 +1728,9 @@ class Interface(object):
 
             android.sound.pause_all()
 
-            pygame.time.set_timer(PERIODIC, 0)
-            pygame.time.set_timer(REDRAW, 0)
-            pygame.time.set_timer(TIMEEVENT, 0)
+            pygame.pygametime.set_timer(PERIODIC, 0)
+            pygame.pygametime.set_timer(REDRAW, 0)
+            pygame.pygametime.set_timer(TIMEEVENT, 0)
 
             # The game has to be saved.
             renpy.loadsave.save("_reload-1")
@@ -1740,7 +1741,7 @@ class Interface(object):
             # auto-reload.
             renpy.loadsave.unlink_save("_reload-1")
 
-            pygame.time.set_timer(PERIODIC, PERIODIC_INTERVAL)
+            pygame.pygametime.set_timer(PERIODIC, PERIODIC_INTERVAL)
 
             android.sound.unpause_all()
             
@@ -2098,7 +2099,14 @@ class Interface(object):
                     
                 # Redraw the screen.
                 if (self.force_redraw or
-                    ((first_pass or not pygame.event.peek(ALL_EVENTS)) and 
+                    ((first_pass or not (
+                        # pygame.event.peek(ALL_EVENTS)
+                        # 0 to TIMEVENT-1
+                        # TIMEVENT + 1 to REDRAW - 1
+                        pygame.event.peek_range(0, TIMEEVENT - 1) or
+                        pygame.event.peek_range(TIMEEVENT + 1, REDRAW - 1)
+                      )
+                     ) and 
                      renpy.display.draw.should_redraw(needs_redraw, first_pass))):
 
                     self.force_redraw = False
@@ -2141,7 +2149,7 @@ class Interface(object):
                     needs_redraw = False
                     first_pass = False
 
-                    pygame.time.set_timer(REDRAW, 0)
+                    pygame.pygametime.set_timer(REDRAW, 0)
                     pygame.event.clear([REDRAW])
                     old_redraw_time = None
                     
@@ -2192,14 +2200,14 @@ class Interface(object):
                             time_left = redraw_time - get_time()
                             time_left = min(time_left, 3600)
                             redraw_in = time_left
-                            pygame.time.set_timer(REDRAW, max(int(time_left * 1000), 1))
+                            pygame.pygametime.set_timer(REDRAW, max(int(time_left * 1000), 1))
                             old_redraw_time = redraw_time
                     else:
-                        pygame.time.set_timer(REDRAW, 0)
+                        pygame.pygametime.set_timer(REDRAW, 0)
 
                     # Handle the timeout timer.
                     if not self.timeout_time:
-                        pygame.time.set_timer(TIMEEVENT, 0)
+                        pygame.pygametime.set_timer(TIMEEVENT, 0)
                         ev = None
                     else:
                         time_left = self.timeout_time - get_time() 
@@ -2209,13 +2217,13 @@ class Interface(object):
                         if time_left < 0:
                             self.timeout_time = None
                             ev = self.time_event
-                            pygame.time.set_timer(TIMEEVENT, 0)
+                            pygame.pygametime.set_timer(TIMEEVENT, 0)
                         else:
                             ev = None
 
                             if self.timeout_time != old_timeout_time:
                                 # Always set to at least 1ms.
-                                pygame.time.set_timer(TIMEEVENT, int(time_left * 1000 + 1))
+                                pygame.pygametime.set_timer(TIMEEVENT, int(time_left * 1000 + 1))
                                 old_timeout_time = self.timeout_time
 
                     # Handle autosaving, as necessary.
@@ -2230,7 +2238,7 @@ class Interface(object):
                         else:
                             ev = self.event_wait()
                         
-                    if ev.type == pygame.NOEVENT:
+                    if ev.type == pygame.FIRSTEVENT:
                         continue
 
                     if renpy.config.profile:
@@ -2387,8 +2395,8 @@ class Interface(object):
             # We no longer disable periodic between interactions.
             # pygame.time.set_timer(PERIODIC, 0)
 
-            pygame.time.set_timer(TIMEEVENT, 0)
-            pygame.time.set_timer(REDRAW, 0)
+            pygame.pygametime.set_timer(TIMEEVENT, 0)
+            pygame.pygametime.set_timer(REDRAW, 0)
 
             renpy.game.context().runtime += end_time - start_time
 
diff --git a/renpy/display/swdraw.py b/renpy/display/swdraw.py
index 380da14..575404b 100644
--- a/renpy/display/swdraw.py
+++ b/renpy/display/swdraw.py
@@ -909,7 +909,7 @@ class SWDraw(object):
             return True
         
         next_frame = self.next_frame
-        now = pygame.time.get_ticks()
+        now = pygame.pygametime.get_ticks()
 
         frametime = 1000.0 / framerate
 
diff --git a/renpy/gl/gldraw.pyx b/renpy/gl/gldraw.pyx
index 277e78f..880a269 100644
--- a/renpy/gl/gldraw.pyx
+++ b/renpy/gl/gldraw.pyx
@@ -146,6 +146,8 @@ cdef class GLDraw:
         can. It returns True if it was succesful, or False if OpenGL isn't
         working for some reason.
         """
+
+        print "In GLDraw.set_mode()"
         
         cdef char *egl_error
         
@@ -186,7 +188,7 @@ cdef class GLDraw:
         pwidth = max(vwidth / 2, pwidth)
         pheight = max(vheight / 2, pheight)
 
-        if renpy.android:
+        if renpy.android or renpy.ios:
             pheight = self.display_info.current_h
             pwidth = self.display_info.current_w
         else:
diff --git a/renpy/log.py b/renpy/log.py
index 611abfe..bb5edca 100644
--- a/renpy/log.py
+++ b/renpy/log.py
@@ -79,7 +79,7 @@ class LogFile(object):
             altfn = os.path.join(tempfile.gettempdir(), "renpy-" + self.name + ".txt")
             
         
-            if renpy.android:
+            if renpy.android or renpy.ios:
                 print "Logging to", fn
 
             if self.append:
